"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/github.ts":
/*!***************************!*\
  !*** ./src/lib/github.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   githubService: function() { return /* binding */ githubService; }\n/* harmony export */ });\n/* harmony import */ var _octokit_rest__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @octokit/rest */ \"(app-pages-browser)/./node_modules/@octokit/rest/dist-src/index.js\");\n// import { Octokit } from '@octokit/rest';\n// import type { RestEndpointMethodTypes } from '@octokit/plugin-rest-endpoint-methods';\n// type UserResponse = RestEndpointMethodTypes[\"users\"][\"getByUsername\"][\"response\"];\n// type ReposResponse = RestEndpointMethodTypes[\"repos\"][\"listForUser\"][\"response\"];\n// type CommitsResponse = RestEndpointMethodTypes[\"repos\"][\"listCommits\"][\"response\"];\n// class GitHubService {\n//   private static instance: GitHubService;\n//   public readonly octokit: Octokit;\n//   private readonly MAX_RETRIES = 3;\n//   private readonly RETRY_DELAY = 1000; // 1 second\n//   private constructor() {\n//     const token = \"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\";\n//     console.log('GitHub token:', token); // Add this line to verify the token\n//     if (!token) {\n//       console.error('GitHub token is not set in environment variables');\n//       throw new Error('GitHub token is not set in environment variables');\n//     }\n//     this.octokit = new Octokit({\n//       auth: token,\n//     });\n//   }\n//   public static getInstance(): GitHubService {\n//     if (!GitHubService.instance) {\n//       GitHubService.instance = new GitHubService();\n//     }\n//     return GitHubService.instance;\n//   }\n//   private async retryOperation<T>(operation: () => Promise<T>): Promise<T> {\n//     let lastError: Error | null = null;\n//     for (let i = 0; i < this.MAX_RETRIES; i++) {\n//       try {\n//         return await operation();\n//       } catch (error: any) {\n//         console.error('GitHub API error:', error);\n//         lastError = error;\n//         if (error.status === 403) {\n//           // Rate limit exceeded, wait longer\n//           await new Promise(resolve => setTimeout(resolve, this.RETRY_DELAY * Math.pow(2, i)));\n//         } else {\n//           throw error;\n//         }\n//       }\n//     }\n//     throw lastError;\n//   }\n//   async getUserData(username: string): Promise<UserResponse> {\n//     console.log('Fetching user data for:', username); // Add this line to verify the username\n//     const data = await this.retryOperation(() => \n//       this.octokit.users.getByUsername({ username })\n//     );\n//     console.log('User Data:', data); // Add this line to verify the response\n//     return data;\n//   }\n//   async getRepositories(username: string = 'kalyanbathula', options: any = {}): Promise<ReposResponse> {\n//     console.log('Fetching repositories for:', username); // Add this line to verify the username\n//     const data = await this.retryOperation(() => \n//       this.octokit.repos.listForUser({ \n//         username: 'kalyanbathula', // Hardcoded username\n//         per_page: 100, \n//         sort: 'updated', \n//         type: 'all', \n//         ...options \n//       })\n//     );\n//     console.log('Repositories Data:', data); // Add this line to verify the response\n//     return data;\n// }\n//   async getRepositoryCommits(owner: string, repo: string, options: any = {}): Promise<CommitsResponse> {\n//     console.log('Fetching commits for:', owner, repo); // Add this line to verify the owner and repo\n//     const data = await this.retryOperation(() => \n//       this.octokit.repos.listCommits({ owner, repo, ...options })\n//     );\n//     console.log('Commits Data:', data); // Add this line to verify the response\n//     return data;\n//   }\n//   async isTokenValid(): Promise<boolean> {\n//     console.log('isTokenValid method called'); // Add this line\n//     try {\n//       const response = await this.octokit.users.getAuthenticated();\n//       console.log(response);\n//       console.log('GitHub Authentication Success:', response.data.login);\n//       return true;\n//     } catch (error) {\n//       console.error('GitHub token validation error:', error);\n//       return false;\n//     }\n//   }\n// }\n// export const githubService = GitHubService.getInstance();\n\nclass GitHubService {\n    static getInstance() {\n        if (!GitHubService.instance) {\n            GitHubService.instance = new GitHubService();\n        }\n        return GitHubService.instance;\n    }\n    async retryOperation(operation) {\n        let lastError = null;\n        for(let i = 0; i < this.MAX_RETRIES; i++){\n            try {\n                return await operation();\n            } catch (error) {\n                console.error(\"GitHub API error:\", error);\n                lastError = error;\n                if (error.status === 403) {\n                    // Rate limit exceeded, wait longer\n                    await new Promise((resolve)=>setTimeout(resolve, this.RETRY_DELAY * Math.pow(2, i)));\n                } else {\n                    throw error;\n                }\n            }\n        }\n        throw lastError;\n    }\n    getCachedData(key) {\n        const cached = this.cache[key];\n        if (cached && Date.now() - cached.timestamp < 3600000) {\n            return cached.data;\n        }\n        return null;\n    }\n    setCachedData(key, data) {\n        this.cache[key] = {\n            data,\n            timestamp: Date.now()\n        };\n    }\n    async getUserData(username) {\n        const cacheKey = \"user_\".concat(username);\n        const cachedData = this.getCachedData(cacheKey);\n        if (cachedData) {\n            console.log(\"Returning cached user data for:\", username);\n            return cachedData;\n        }\n        console.log(\"Fetching user data for:\", username); // Add this line to verify the username\n        const data = await this.retryOperation(()=>this.octokit.users.getByUsername({\n                username\n            }));\n        console.log(\"User Data:\", data); // Add this line to verify the response\n        this.setCachedData(cacheKey, data);\n        return data;\n    }\n    async getRepositories() {\n        let username = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"kalyanbathula\", options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const cacheKey = \"repos_\".concat(username);\n        const cachedData = this.getCachedData(cacheKey);\n        if (cachedData) {\n            console.log(\"Returning cached repositories data for:\", username);\n            return cachedData;\n        }\n        console.log(\"Fetching repositories for:\", username); // Add this line to verify the username\n        const data = await this.retryOperation(()=>this.octokit.repos.listForUser({\n                username: \"kalyanbathula\",\n                per_page: 100,\n                sort: \"updated\",\n                type: \"all\",\n                ...options\n            }));\n        console.log(\"Repositories Data:\", data); // Add this line to verify the response\n        this.setCachedData(cacheKey, data);\n        return data;\n    }\n    async getRepositoryCommits(owner, repo) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const cacheKey = \"commits_\".concat(owner, \"_\").concat(repo);\n        const cachedData = this.getCachedData(cacheKey);\n        if (cachedData) {\n            console.log(\"Returning cached commits data for:\", owner, repo);\n            return cachedData;\n        }\n        console.log(\"Fetching commits for:\", owner, repo); // Add this line to verify the owner and repo\n        const data = await this.retryOperation(()=>this.octokit.repos.listCommits({\n                owner,\n                repo,\n                ...options\n            }));\n        console.log(\"Commits Data:\", data); // Add this line to verify the response\n        this.setCachedData(cacheKey, data);\n        return data;\n    }\n    async isTokenValid() {\n        console.log(\"isTokenValid method called\"); // Add this line\n        try {\n            const response = await this.octokit.users.getAuthenticated();\n            console.log(response);\n            console.log(\"GitHub Authentication Success:\", response.data.login);\n            return true;\n        } catch (error) {\n            console.error(\"GitHub token validation error:\", error);\n            return false;\n        }\n    }\n    constructor(){\n        this.MAX_RETRIES = 3;\n        this.RETRY_DELAY = 1000 // 1 second\n        ;\n        this.cache = {} // Cache object\n        ;\n        const token = \"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\";\n        console.log(\"GitHub token:\", token); // Add this line to verify the token\n        if (!token) {\n            console.error(\"GitHub token is not set in environment variables\");\n            throw new Error(\"GitHub token is not set in environment variables\");\n        }\n        this.octokit = new _octokit_rest__WEBPACK_IMPORTED_MODULE_0__.Octokit({\n            auth: token\n        });\n    }\n}\nconst githubService = GitHubService.getInstance();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFLO1lBQ2pFLE9BQU87UUFDVCxFQUFFLE9BQU94QyxPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQyxrQ0FBa0NBO1lBQ2hELE9BQU87UUFDVDtJQUNGO0lBekhBLGFBQXNCO2FBSkxELGNBQWM7YUFDZE8sY0FBYyxLQUFNLFdBQVc7O2FBQ3hDTSxRQUFnQyxDQUFDLEVBQUcsZUFBZTs7UUFHekQsTUFBTTZCLFFBQVE7UUFDZHhDLFFBQVFxQixHQUFHLENBQUMsaUJBQWlCbUIsUUFBUSxvQ0FBb0M7UUFDekUsSUFBSSxDQUFDQSxPQUFPO1lBQ1Z4QyxRQUFRRCxLQUFLLENBQUM7WUFDZCxNQUFNLElBQUkwQyxNQUFNO1FBQ2xCO1FBQ0EsSUFBSSxDQUFDbkIsT0FBTyxHQUFHLElBQUloQyxrREFBT0EsQ0FBQztZQUN6Qm9ELE1BQU1GO1FBQ1I7SUFDRjtBQWdIRjtBQUVPLE1BQU1HLGdCQUFnQnBELGNBQWNDLFdBQVcsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL2dpdGh1Yi50cz9kNjRlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGltcG9ydCB7IE9jdG9raXQgfSBmcm9tICdAb2N0b2tpdC9yZXN0JztcclxuLy8gaW1wb3J0IHR5cGUgeyBSZXN0RW5kcG9pbnRNZXRob2RUeXBlcyB9IGZyb20gJ0BvY3Rva2l0L3BsdWdpbi1yZXN0LWVuZHBvaW50LW1ldGhvZHMnO1xyXG5cclxuLy8gdHlwZSBVc2VyUmVzcG9uc2UgPSBSZXN0RW5kcG9pbnRNZXRob2RUeXBlc1tcInVzZXJzXCJdW1wiZ2V0QnlVc2VybmFtZVwiXVtcInJlc3BvbnNlXCJdO1xyXG4vLyB0eXBlIFJlcG9zUmVzcG9uc2UgPSBSZXN0RW5kcG9pbnRNZXRob2RUeXBlc1tcInJlcG9zXCJdW1wibGlzdEZvclVzZXJcIl1bXCJyZXNwb25zZVwiXTtcclxuLy8gdHlwZSBDb21taXRzUmVzcG9uc2UgPSBSZXN0RW5kcG9pbnRNZXRob2RUeXBlc1tcInJlcG9zXCJdW1wibGlzdENvbW1pdHNcIl1bXCJyZXNwb25zZVwiXTtcclxuXHJcbi8vIGNsYXNzIEdpdEh1YlNlcnZpY2Uge1xyXG4vLyAgIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBHaXRIdWJTZXJ2aWNlO1xyXG4vLyAgIHB1YmxpYyByZWFkb25seSBvY3Rva2l0OiBPY3Rva2l0O1xyXG4vLyAgIHByaXZhdGUgcmVhZG9ubHkgTUFYX1JFVFJJRVMgPSAzO1xyXG4vLyAgIHByaXZhdGUgcmVhZG9ubHkgUkVUUllfREVMQVkgPSAxMDAwOyAvLyAxIHNlY29uZFxyXG5cclxuLy8gICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge1xyXG4vLyAgICAgY29uc3QgdG9rZW4gPSBcImdocF82MFN0aUtwa0lEZlZ5OXh2ODRZQVhGSHZ2SDhJMlQySnZXVlhcIjtcclxuLy8gICAgIGNvbnNvbGUubG9nKCdHaXRIdWIgdG9rZW46JywgdG9rZW4pOyAvLyBBZGQgdGhpcyBsaW5lIHRvIHZlcmlmeSB0aGUgdG9rZW5cclxuLy8gICAgIGlmICghdG9rZW4pIHtcclxuLy8gICAgICAgY29uc29sZS5lcnJvcignR2l0SHViIHRva2VuIGlzIG5vdCBzZXQgaW4gZW52aXJvbm1lbnQgdmFyaWFibGVzJyk7XHJcbi8vICAgICAgIHRocm93IG5ldyBFcnJvcignR2l0SHViIHRva2VuIGlzIG5vdCBzZXQgaW4gZW52aXJvbm1lbnQgdmFyaWFibGVzJyk7XHJcbi8vICAgICB9XHJcbi8vICAgICB0aGlzLm9jdG9raXQgPSBuZXcgT2N0b2tpdCh7XHJcbi8vICAgICAgIGF1dGg6IHRva2VuLFxyXG4vLyAgICAgfSk7XHJcbi8vICAgfVxyXG5cclxuLy8gICBwdWJsaWMgc3RhdGljIGdldEluc3RhbmNlKCk6IEdpdEh1YlNlcnZpY2Uge1xyXG4vLyAgICAgaWYgKCFHaXRIdWJTZXJ2aWNlLmluc3RhbmNlKSB7XHJcbi8vICAgICAgIEdpdEh1YlNlcnZpY2UuaW5zdGFuY2UgPSBuZXcgR2l0SHViU2VydmljZSgpO1xyXG4vLyAgICAgfVxyXG4vLyAgICAgcmV0dXJuIEdpdEh1YlNlcnZpY2UuaW5zdGFuY2U7XHJcbi8vICAgfVxyXG5cclxuLy8gICBwcml2YXRlIGFzeW5jIHJldHJ5T3BlcmF0aW9uPFQ+KG9wZXJhdGlvbjogKCkgPT4gUHJvbWlzZTxUPik6IFByb21pc2U8VD4ge1xyXG4vLyAgICAgbGV0IGxhc3RFcnJvcjogRXJyb3IgfCBudWxsID0gbnVsbDtcclxuLy8gICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5NQVhfUkVUUklFUzsgaSsrKSB7XHJcbi8vICAgICAgIHRyeSB7XHJcbi8vICAgICAgICAgcmV0dXJuIGF3YWl0IG9wZXJhdGlvbigpO1xyXG4vLyAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbi8vICAgICAgICAgY29uc29sZS5lcnJvcignR2l0SHViIEFQSSBlcnJvcjonLCBlcnJvcik7XHJcbi8vICAgICAgICAgbGFzdEVycm9yID0gZXJyb3I7XHJcbi8vICAgICAgICAgaWYgKGVycm9yLnN0YXR1cyA9PT0gNDAzKSB7XHJcbi8vICAgICAgICAgICAvLyBSYXRlIGxpbWl0IGV4Y2VlZGVkLCB3YWl0IGxvbmdlclxyXG4vLyAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRoaXMuUkVUUllfREVMQVkgKiBNYXRoLnBvdygyLCBpKSkpO1xyXG4vLyAgICAgICAgIH0gZWxzZSB7XHJcbi8vICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuLy8gICAgICAgICB9XHJcbi8vICAgICAgIH1cclxuLy8gICAgIH1cclxuLy8gICAgIHRocm93IGxhc3RFcnJvcjtcclxuLy8gICB9XHJcblxyXG4vLyAgIGFzeW5jIGdldFVzZXJEYXRhKHVzZXJuYW1lOiBzdHJpbmcpOiBQcm9taXNlPFVzZXJSZXNwb25zZT4ge1xyXG4vLyAgICAgY29uc29sZS5sb2coJ0ZldGNoaW5nIHVzZXIgZGF0YSBmb3I6JywgdXNlcm5hbWUpOyAvLyBBZGQgdGhpcyBsaW5lIHRvIHZlcmlmeSB0aGUgdXNlcm5hbWVcclxuLy8gICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLnJldHJ5T3BlcmF0aW9uKCgpID0+IFxyXG4vLyAgICAgICB0aGlzLm9jdG9raXQudXNlcnMuZ2V0QnlVc2VybmFtZSh7IHVzZXJuYW1lIH0pXHJcbi8vICAgICApO1xyXG4vLyAgICAgY29uc29sZS5sb2coJ1VzZXIgRGF0YTonLCBkYXRhKTsgLy8gQWRkIHRoaXMgbGluZSB0byB2ZXJpZnkgdGhlIHJlc3BvbnNlXHJcbi8vICAgICByZXR1cm4gZGF0YTtcclxuLy8gICB9XHJcblxyXG4vLyAgIGFzeW5jIGdldFJlcG9zaXRvcmllcyh1c2VybmFtZTogc3RyaW5nID0gJ2thbHlhbmJhdGh1bGEnLCBvcHRpb25zOiBhbnkgPSB7fSk6IFByb21pc2U8UmVwb3NSZXNwb25zZT4ge1xyXG4vLyAgICAgY29uc29sZS5sb2coJ0ZldGNoaW5nIHJlcG9zaXRvcmllcyBmb3I6JywgdXNlcm5hbWUpOyAvLyBBZGQgdGhpcyBsaW5lIHRvIHZlcmlmeSB0aGUgdXNlcm5hbWVcclxuLy8gICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLnJldHJ5T3BlcmF0aW9uKCgpID0+IFxyXG4vLyAgICAgICB0aGlzLm9jdG9raXQucmVwb3MubGlzdEZvclVzZXIoeyBcclxuLy8gICAgICAgICB1c2VybmFtZTogJ2thbHlhbmJhdGh1bGEnLCAvLyBIYXJkY29kZWQgdXNlcm5hbWVcclxuLy8gICAgICAgICBwZXJfcGFnZTogMTAwLCBcclxuLy8gICAgICAgICBzb3J0OiAndXBkYXRlZCcsIFxyXG4vLyAgICAgICAgIHR5cGU6ICdhbGwnLCBcclxuLy8gICAgICAgICAuLi5vcHRpb25zIFxyXG4vLyAgICAgICB9KVxyXG4vLyAgICAgKTtcclxuLy8gICAgIGNvbnNvbGUubG9nKCdSZXBvc2l0b3JpZXMgRGF0YTonLCBkYXRhKTsgLy8gQWRkIHRoaXMgbGluZSB0byB2ZXJpZnkgdGhlIHJlc3BvbnNlXHJcbi8vICAgICByZXR1cm4gZGF0YTtcclxuLy8gfVxyXG5cclxuLy8gICBhc3luYyBnZXRSZXBvc2l0b3J5Q29tbWl0cyhvd25lcjogc3RyaW5nLCByZXBvOiBzdHJpbmcsIG9wdGlvbnM6IGFueSA9IHt9KTogUHJvbWlzZTxDb21taXRzUmVzcG9uc2U+IHtcclxuLy8gICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyBjb21taXRzIGZvcjonLCBvd25lciwgcmVwbyk7IC8vIEFkZCB0aGlzIGxpbmUgdG8gdmVyaWZ5IHRoZSBvd25lciBhbmQgcmVwb1xyXG4vLyAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMucmV0cnlPcGVyYXRpb24oKCkgPT4gXHJcbi8vICAgICAgIHRoaXMub2N0b2tpdC5yZXBvcy5saXN0Q29tbWl0cyh7IG93bmVyLCByZXBvLCAuLi5vcHRpb25zIH0pXHJcbi8vICAgICApO1xyXG4vLyAgICAgY29uc29sZS5sb2coJ0NvbW1pdHMgRGF0YTonLCBkYXRhKTsgLy8gQWRkIHRoaXMgbGluZSB0byB2ZXJpZnkgdGhlIHJlc3BvbnNlXHJcbi8vICAgICByZXR1cm4gZGF0YTtcclxuLy8gICB9XHJcblxyXG5cclxuLy8gICBhc3luYyBpc1Rva2VuVmFsaWQoKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbi8vICAgICBjb25zb2xlLmxvZygnaXNUb2tlblZhbGlkIG1ldGhvZCBjYWxsZWQnKTsgLy8gQWRkIHRoaXMgbGluZVxyXG4vLyAgICAgdHJ5IHtcclxuLy8gICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLm9jdG9raXQudXNlcnMuZ2V0QXV0aGVudGljYXRlZCgpO1xyXG4vLyAgICAgICBjb25zb2xlLmxvZyhyZXNwb25zZSk7XHJcbi8vICAgICAgIGNvbnNvbGUubG9nKCdHaXRIdWIgQXV0aGVudGljYXRpb24gU3VjY2VzczonLCByZXNwb25zZS5kYXRhLmxvZ2luKTtcclxuLy8gICAgICAgcmV0dXJuIHRydWU7XHJcbi8vICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4vLyAgICAgICBjb25zb2xlLmVycm9yKCdHaXRIdWIgdG9rZW4gdmFsaWRhdGlvbiBlcnJvcjonLCBlcnJvcik7XHJcbi8vICAgICAgIHJldHVybiBmYWxzZTtcclxuLy8gICAgIH1cclxuLy8gICB9XHJcbi8vIH1cclxuXHJcbi8vIGV4cG9ydCBjb25zdCBnaXRodWJTZXJ2aWNlID0gR2l0SHViU2VydmljZS5nZXRJbnN0YW5jZSgpO1xyXG5cclxuaW1wb3J0IHsgT2N0b2tpdCB9IGZyb20gJ0BvY3Rva2l0L3Jlc3QnO1xyXG5pbXBvcnQgdHlwZSB7IFJlc3RFbmRwb2ludE1ldGhvZFR5cGVzIH0gZnJvbSAnQG9jdG9raXQvcGx1Z2luLXJlc3QtZW5kcG9pbnQtbWV0aG9kcyc7XHJcblxyXG50eXBlIFVzZXJSZXNwb25zZSA9IFJlc3RFbmRwb2ludE1ldGhvZFR5cGVzW1widXNlcnNcIl1bXCJnZXRCeVVzZXJuYW1lXCJdW1wicmVzcG9uc2VcIl07XHJcbnR5cGUgUmVwb3NSZXNwb25zZSA9IFJlc3RFbmRwb2ludE1ldGhvZFR5cGVzW1wicmVwb3NcIl1bXCJsaXN0Rm9yVXNlclwiXVtcInJlc3BvbnNlXCJdO1xyXG50eXBlIENvbW1pdHNSZXNwb25zZSA9IFJlc3RFbmRwb2ludE1ldGhvZFR5cGVzW1wicmVwb3NcIl1bXCJsaXN0Q29tbWl0c1wiXVtcInJlc3BvbnNlXCJdO1xyXG5cclxuY2xhc3MgR2l0SHViU2VydmljZSB7XHJcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IEdpdEh1YlNlcnZpY2U7XHJcbiAgcHVibGljIHJlYWRvbmx5IG9jdG9raXQ6IE9jdG9raXQ7XHJcbiAgcHJpdmF0ZSByZWFkb25seSBNQVhfUkVUUklFUyA9IDM7XHJcbiAgcHJpdmF0ZSByZWFkb25seSBSRVRSWV9ERUxBWSA9IDEwMDA7IC8vIDEgc2Vjb25kXHJcbiAgcHJpdmF0ZSBjYWNoZTogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9OyAvLyBDYWNoZSBvYmplY3RcclxuXHJcbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHtcclxuICAgIGNvbnN0IHRva2VuID0gXCJnaHBfNjBTdGlLcGtJRGZWeTl4djg0WUFYRkh2dkg4STJUMkp2V1ZYXCI7XHJcbiAgICBjb25zb2xlLmxvZygnR2l0SHViIHRva2VuOicsIHRva2VuKTsgLy8gQWRkIHRoaXMgbGluZSB0byB2ZXJpZnkgdGhlIHRva2VuXHJcbiAgICBpZiAoIXRva2VuKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0dpdEh1YiB0b2tlbiBpcyBub3Qgc2V0IGluIGVudmlyb25tZW50IHZhcmlhYmxlcycpO1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dpdEh1YiB0b2tlbiBpcyBub3Qgc2V0IGluIGVudmlyb25tZW50IHZhcmlhYmxlcycpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5vY3Rva2l0ID0gbmV3IE9jdG9raXQoe1xyXG4gICAgICBhdXRoOiB0b2tlbixcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBHaXRIdWJTZXJ2aWNlIHtcclxuICAgIGlmICghR2l0SHViU2VydmljZS5pbnN0YW5jZSkge1xyXG4gICAgICBHaXRIdWJTZXJ2aWNlLmluc3RhbmNlID0gbmV3IEdpdEh1YlNlcnZpY2UoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBHaXRIdWJTZXJ2aWNlLmluc3RhbmNlO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyByZXRyeU9wZXJhdGlvbjxUPihvcGVyYXRpb246ICgpID0+IFByb21pc2U8VD4pOiBQcm9taXNlPFQ+IHtcclxuICAgIGxldCBsYXN0RXJyb3I6IEVycm9yIHwgbnVsbCA9IG51bGw7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuTUFYX1JFVFJJRVM7IGkrKykge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCBvcGVyYXRpb24oKTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0dpdEh1YiBBUEkgZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgICAgIGxhc3RFcnJvciA9IGVycm9yO1xyXG4gICAgICAgIGlmIChlcnJvci5zdGF0dXMgPT09IDQwMykge1xyXG4gICAgICAgICAgLy8gUmF0ZSBsaW1pdCBleGNlZWRlZCwgd2FpdCBsb25nZXJcclxuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aGlzLlJFVFJZX0RFTEFZICogTWF0aC5wb3coMiwgaSkpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0aHJvdyBsYXN0RXJyb3I7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGdldENhY2hlZERhdGE8VD4oa2V5OiBzdHJpbmcpOiBUIHwgbnVsbCB7XHJcbiAgICBjb25zdCBjYWNoZWQgPSB0aGlzLmNhY2hlW2tleV07XHJcbiAgICBpZiAoY2FjaGVkICYmIChEYXRlLm5vdygpIC0gY2FjaGVkLnRpbWVzdGFtcCA8IDM2MDAwMDApKSB7IC8vIENhY2hlIGZvciAxIGhvdXJcclxuICAgICAgcmV0dXJuIGNhY2hlZC5kYXRhO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHNldENhY2hlZERhdGE8VD4oa2V5OiBzdHJpbmcsIGRhdGE6IFQpOiB2b2lkIHtcclxuICAgIHRoaXMuY2FjaGVba2V5XSA9IHtcclxuICAgICAgZGF0YSxcclxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0VXNlckRhdGEodXNlcm5hbWU6IHN0cmluZyk6IFByb21pc2U8VXNlclJlc3BvbnNlPiB7XHJcbiAgICBjb25zdCBjYWNoZUtleSA9IGB1c2VyXyR7dXNlcm5hbWV9YDtcclxuICAgIGNvbnN0IGNhY2hlZERhdGEgPSB0aGlzLmdldENhY2hlZERhdGE8VXNlclJlc3BvbnNlPihjYWNoZUtleSk7XHJcbiAgICBpZiAoY2FjaGVkRGF0YSkge1xyXG4gICAgICBjb25zb2xlLmxvZygnUmV0dXJuaW5nIGNhY2hlZCB1c2VyIGRhdGEgZm9yOicsIHVzZXJuYW1lKTtcclxuICAgICAgcmV0dXJuIGNhY2hlZERhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coJ0ZldGNoaW5nIHVzZXIgZGF0YSBmb3I6JywgdXNlcm5hbWUpOyAvLyBBZGQgdGhpcyBsaW5lIHRvIHZlcmlmeSB0aGUgdXNlcm5hbWVcclxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLnJldHJ5T3BlcmF0aW9uKCgpID0+IFxyXG4gICAgICB0aGlzLm9jdG9raXQudXNlcnMuZ2V0QnlVc2VybmFtZSh7IHVzZXJuYW1lIH0pXHJcbiAgICApO1xyXG4gICAgY29uc29sZS5sb2coJ1VzZXIgRGF0YTonLCBkYXRhKTsgLy8gQWRkIHRoaXMgbGluZSB0byB2ZXJpZnkgdGhlIHJlc3BvbnNlXHJcbiAgICB0aGlzLnNldENhY2hlZERhdGEoY2FjaGVLZXksIGRhdGEpO1xyXG4gICAgcmV0dXJuIGRhdGE7XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRSZXBvc2l0b3JpZXModXNlcm5hbWU6IHN0cmluZyA9ICdrYWx5YW5iYXRodWxhJywgb3B0aW9uczogYW55ID0ge30pOiBQcm9taXNlPFJlcG9zUmVzcG9uc2U+IHtcclxuICAgIGNvbnN0IGNhY2hlS2V5ID0gYHJlcG9zXyR7dXNlcm5hbWV9YDtcclxuICAgIGNvbnN0IGNhY2hlZERhdGEgPSB0aGlzLmdldENhY2hlZERhdGE8UmVwb3NSZXNwb25zZT4oY2FjaGVLZXkpO1xyXG4gICAgaWYgKGNhY2hlZERhdGEpIHtcclxuICAgICAgY29uc29sZS5sb2coJ1JldHVybmluZyBjYWNoZWQgcmVwb3NpdG9yaWVzIGRhdGEgZm9yOicsIHVzZXJuYW1lKTtcclxuICAgICAgcmV0dXJuIGNhY2hlZERhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coJ0ZldGNoaW5nIHJlcG9zaXRvcmllcyBmb3I6JywgdXNlcm5hbWUpOyAvLyBBZGQgdGhpcyBsaW5lIHRvIHZlcmlmeSB0aGUgdXNlcm5hbWVcclxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLnJldHJ5T3BlcmF0aW9uKCgpID0+IFxyXG4gICAgICB0aGlzLm9jdG9raXQucmVwb3MubGlzdEZvclVzZXIoeyBcclxuICAgICAgICB1c2VybmFtZTogJ2thbHlhbmJhdGh1bGEnLCAvLyBIYXJkY29kZWQgdXNlcm5hbWVcclxuICAgICAgICBwZXJfcGFnZTogMTAwLCBcclxuICAgICAgICBzb3J0OiAndXBkYXRlZCcsIFxyXG4gICAgICAgIHR5cGU6ICdhbGwnLCBcclxuICAgICAgICAuLi5vcHRpb25zIFxyXG4gICAgICB9KVxyXG4gICAgKTtcclxuICAgIGNvbnNvbGUubG9nKCdSZXBvc2l0b3JpZXMgRGF0YTonLCBkYXRhKTsgLy8gQWRkIHRoaXMgbGluZSB0byB2ZXJpZnkgdGhlIHJlc3BvbnNlXHJcbiAgICB0aGlzLnNldENhY2hlZERhdGEoY2FjaGVLZXksIGRhdGEpO1xyXG4gICAgcmV0dXJuIGRhdGE7XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRSZXBvc2l0b3J5Q29tbWl0cyhvd25lcjogc3RyaW5nLCByZXBvOiBzdHJpbmcsIG9wdGlvbnM6IGFueSA9IHt9KTogUHJvbWlzZTxDb21taXRzUmVzcG9uc2U+IHtcclxuICAgIGNvbnN0IGNhY2hlS2V5ID0gYGNvbW1pdHNfJHtvd25lcn1fJHtyZXBvfWA7XHJcbiAgICBjb25zdCBjYWNoZWREYXRhID0gdGhpcy5nZXRDYWNoZWREYXRhPENvbW1pdHNSZXNwb25zZT4oY2FjaGVLZXkpO1xyXG4gICAgaWYgKGNhY2hlZERhdGEpIHtcclxuICAgICAgY29uc29sZS5sb2coJ1JldHVybmluZyBjYWNoZWQgY29tbWl0cyBkYXRhIGZvcjonLCBvd25lciwgcmVwbyk7XHJcbiAgICAgIHJldHVybiBjYWNoZWREYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyBjb21taXRzIGZvcjonLCBvd25lciwgcmVwbyk7IC8vIEFkZCB0aGlzIGxpbmUgdG8gdmVyaWZ5IHRoZSBvd25lciBhbmQgcmVwb1xyXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMucmV0cnlPcGVyYXRpb24oKCkgPT4gXHJcbiAgICAgIHRoaXMub2N0b2tpdC5yZXBvcy5saXN0Q29tbWl0cyh7IG93bmVyLCByZXBvLCAuLi5vcHRpb25zIH0pXHJcbiAgICApO1xyXG4gICAgY29uc29sZS5sb2coJ0NvbW1pdHMgRGF0YTonLCBkYXRhKTsgLy8gQWRkIHRoaXMgbGluZSB0byB2ZXJpZnkgdGhlIHJlc3BvbnNlXHJcbiAgICB0aGlzLnNldENhY2hlZERhdGEoY2FjaGVLZXksIGRhdGEpO1xyXG4gICAgcmV0dXJuIGRhdGE7XHJcbiAgfVxyXG5cclxuICBhc3luYyBpc1Rva2VuVmFsaWQoKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICBjb25zb2xlLmxvZygnaXNUb2tlblZhbGlkIG1ldGhvZCBjYWxsZWQnKTsgLy8gQWRkIHRoaXMgbGluZVxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLm9jdG9raXQudXNlcnMuZ2V0QXV0aGVudGljYXRlZCgpO1xyXG4gICAgICBjb25zb2xlLmxvZyhyZXNwb25zZSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdHaXRIdWIgQXV0aGVudGljYXRpb24gU3VjY2VzczonLCByZXNwb25zZS5kYXRhLmxvZ2luKTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdHaXRIdWIgdG9rZW4gdmFsaWRhdGlvbiBlcnJvcjonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBnaXRodWJTZXJ2aWNlID0gR2l0SHViU2VydmljZS5nZXRJbnN0YW5jZSgpOyJdLCJuYW1lcyI6WyJPY3Rva2l0IiwiR2l0SHViU2VydmljZSIsImdldEluc3RhbmNlIiwiaW5zdGFuY2UiLCJyZXRyeU9wZXJhdGlvbiIsIm9wZXJhdGlvbiIsImxhc3RFcnJvciIsImkiLCJNQVhfUkVUUklFUyIsImVycm9yIiwiY29uc29sZSIsInN0YXR1cyIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsIlJFVFJZX0RFTEFZIiwiTWF0aCIsInBvdyIsImdldENhY2hlZERhdGEiLCJrZXkiLCJjYWNoZWQiLCJjYWNoZSIsIkRhdGUiLCJub3ciLCJ0aW1lc3RhbXAiLCJkYXRhIiwic2V0Q2FjaGVkRGF0YSIsImdldFVzZXJEYXRhIiwidXNlcm5hbWUiLCJjYWNoZUtleSIsImNhY2hlZERhdGEiLCJsb2ciLCJvY3Rva2l0IiwidXNlcnMiLCJnZXRCeVVzZXJuYW1lIiwiZ2V0UmVwb3NpdG9yaWVzIiwib3B0aW9ucyIsInJlcG9zIiwibGlzdEZvclVzZXIiLCJwZXJfcGFnZSIsInNvcnQiLCJ0eXBlIiwiZ2V0UmVwb3NpdG9yeUNvbW1pdHMiLCJvd25lciIsInJlcG8iLCJsaXN0Q29tbWl0cyIsImlzVG9rZW5WYWxpZCIsInJlc3BvbnNlIiwiZ2V0QXV0aGVudGljYXRlZCIsImxvZ2luIiwidG9rZW4iLCJFcnJvciIsImF1dGgiLCJnaXRodWJTZXJ2aWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/github.ts\n"));

/***/ })

});